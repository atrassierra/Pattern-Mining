import random
import argparse
import statistics as st

from individual import Individual

def division(a, b):
    try:
        return float(a / b)
    except ZeroDivisionError:
        return float("inf")

class Elite():
    """
    Elite Class

    This class contains the best individuals generated by the algorithm after g number of generations
    """
    def __init__(self, args, items, population): # Para cuando esta vacia y se crea elite, meter con la poblaciÃ³n inicial
        self.args = args
        self.items = items
        self.elite = dict()
        for group in self.items:
            self.elite[group] = []
            try:
                for individual in range(self.args.elite_size):
                    self.elite[group].append(population[individual])
                self.orderElitegroup(group)
            except:
                print("Elite must have less size than the population")

    def update(self, generation): # generation is the population at that moment para cuando existe elite y actualizas
        for group in self.elite:
            for individual in generation:
                if self.isGreater(individual, self.elite[group][-1], group) and individual not in self.elite[group]:
                    self.elite[group][-1] = individual
                    self.orderElitegroup(group)
                elif self.isEqual(individual, self.elite[group][-1], group):
                    if individual.calculateSupport(group) > self.elite[group][-1].calculateSupport(group) and individual not in self.elite[group]:
                        self.elite[group][-1] = individual
                        self.orderElitegroup(group)

    def isGreater(self, ind1, ind2, group):
        ind1Fitness = []
        ind2Fitness = []
        for comparison in ind1.fitness.keys():
            if comparison[0] == group:
                ind1Fitness.append(ind1.fitness[comparison])
                ind2Fitness.append(ind2.fitness[comparison])
        if st.mean(ind1Fitness) < st.mean(ind2Fitness):
            return True

    def isEqual(self, ind1, ind2, group):
        ind1Fitness = []
        ind2Fitness = []
        for comparison in ind1.fitness.keys():
            if comparison[0] == group:
                ind1Fitness.append(ind1.fitness[comparison])
                ind2Fitness.append(ind2.fitness[comparison])
        if st.mean(ind1Fitness) == st.mean(ind2Fitness):
            return True

    def orderElitegroup(self, group):
        for indIndex in range(self.elite[group] - 1):
            if self.isGreater(self.elite[group][indIndex + 1], self.elite[group][indIndex], group):
                auxIndividual = self.elite[group][indIndex]
                self.elite[group][indIndex] = self.elite[group][indIndex + 1]
                self.elite[group][indIndex + 1] = auxIndividual
            elif self.isEqual(self.elite[group][indIndex + 1], self.elite[group][indIndex], group):
                if self.elite[group][indIndex + 1].calculateSupport(group) > self.elite[group][indIndex].calculateSupport(group):
                    auxIndividual = self.elite[group][indIndex]
                    self.elite[group][indIndex] = self.elite[group][indIndex + 1]
                    self.elite[group][indIndex + 1] = auxIndividual

    def eliteStatistics(self):
        pass