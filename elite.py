import random
import argparse
import statistics as st

from individual import Individual

def division(a, b):
    try:
        return float(a / b)
    except ZeroDivisionError:
        return float("inf")

class Elite():
    """
    Elite Class

    This class contains the best individuals generated by the algorithm after g number of generations
    """
    def __init__(self, args, items, population): # Para cuando esta vacia y se crea elite, meter con la poblaci√≥n inicial
        self.args = args
        self.items = items
        self.elite = dict()
        for group in self.items:
            self.elite[group] = []
            try:
                for individual in range(self.args.elite_size):
                    self.elite[group].append(population[individual])
                self.orderElitegroup(group)
            except:
                print("Elite must have less size than the population")

    def update(self, generation): # generation is the population at that moment para cuando existe elite y actualizas
        for group in self.elite:
            for individual in generation:
                if self.isGreater(individual, self.elite[group][-1], group) and individual not in self.elite[group]:
                    self.elite[group][-1] = individual
                    self.orderElitegroup(group)

    def isGreater(self, ind1, ind2, group): # FITNESS AHORA ES UNA TUPLA (1/GR, SUP1)
        ind1Fitness = []
        ind2Fitness = []
        for comparison in ind1.fitness.keys():
            if comparison[0] == group:
                ind1Fitness.append(ind1.fitness[comparison][0])
                supInd1 = ind1.fitness[comparison][1] # Se puede machacar ya que el sup siempre es el mismo
                ind2Fitness.append(ind2.fitness[comparison][0])
                supInd2 = ind2.fitness[comparison][1]
        if st.mean(ind1Fitness) < st.mean(ind2Fitness):
            return True
        elif st.mean(ind1Fitness) ==  st.mean(ind2Fitness):
            if supInd1 > supInd2:
                return True

    def orderElitegroup(self, group):
        for indIndex in range(self.elite[group] - 1):
            if self.isGreater(self.elite[group][indIndex + 1], self.elite[group][indIndex], group):
                auxIndividual = self.elite[group][indIndex]
                self.elite[group][indIndex] = self.elite[group][indIndex + 1]
                self.elite[group][indIndex + 1] = auxIndividual

    def eliteStatistics(self):
        pass